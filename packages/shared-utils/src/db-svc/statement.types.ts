import { Collection, Db, Filter, ObjectId, Sort, UpdateResult } from "mongodb";
import { DatabaseError } from "../error-handlers/app-errors.js";
import { Log, LoggingService } from "../logging/logging.types.js";
import { StatementTypes } from "../app-config/ApplicationConfig.js";

/**
 * Represents one line item with a single value.
 * Example: { "Net Revenue": 12345 }
 **/
export type SingleValueItem = Record<string, string | number>;

/**
 * Represents one line item with multiple values (typically for Equity statements).
 * Example: { "Common Stock": [100, 110, 120] }
 **/
export type MultiValueItem = Record<string, string[] | number[]>;
export interface StatementDoc {
        /**
         * Unique identifier. Can be auto-generated by Mongo (ObjectId)
         * or a custom composite string like CIK_ACCESSION_FORMTYPE_STMTTYPE_SOURCEFILE.
         */
        _id?: string | ObjectId;
    
        // --- Context Fields (From FilingDataConfig) ---
        ticker: string;
        cik: string; // Store canonical CIK (string)
        accessionNumber: string; // Store canonical accession number
        formType: string; // e.g., '10-K', '10-Q'
        filingDate: Date; // Store as native BSON Date
        reportDate?: Date; // Store as native BSON Date (end date of the period reported)
        companyName?: string;
    
        // --- Statement Specific Fields ---
        /**
         * Type of statement (e.g., 'INCOME', 'BALANCE', 'CASHFLOW', 'EQUITY').
         * Used to determine the expected structure within parsedData.
         */
        statementType: string;
        /**
         * The source filename within the SEC filing (e.g., 'R1.htm', 'R5.htm').
         */
        sourceFile: string;
    
        /**
         * The actual parsed financial data. The structure of items within the array
         * depends on the statementType. Use type guards based on statementType
         * when reading this data.
         */
        parsedData: any; //Array<SingleValueItem | MultiValueItem>;
    
        // --- Metadata ---
        /**
         * Timestamp of when this document was created/updated in the database.
         */
        processedAt: Date;
    
}

export interface StatementDao {
    /**
     * Inserts a new statement document or updates an existing one
     * based on a unique combination of CIK, Accession Number, Form Type, and Source File.
     * @param statementDoc - The complete statement document to save.
     * @returns {Promise<boolean>} - True if a document was inserted or updated, false otherwise.
     * @throws {DatabaseError} - If the database operation fails.
     */
    upsertStatement(statement:StatementDoc):Promise<boolean>;

    /**
     * Finds all statement documents associated with a specific SEC filing.
     * @param ticker - The ticker of the company.
     * @param accessionNumber - The accession number of the filing.
     * @param formType - The form type (e.g., '10-K').
     * @returns {Promise<StatementDoc[]>} - An array of matching statement documents.
     * @throws {DatabaseError} - If the database operation fails.
     */
    findStatementsByFiling(ticker: string, accessionNumber: string, formType: string): Promise<StatementDoc[]>;

    /**
     * Finds statement documents for a specific ticker, optionally filtered by statement type.
     * @param ticker - The stock ticker symbol.
     * @param limit - Optional: Maximum number of results to return.
     * @param sortOrder - Optional: Sort direction for filingDate (-1 for descending, 1 for ascending).
     * @returns {Promise<StatementDoc[]>} - An array of matching statement documents.
     * @throws {DatabaseError} - If the database operation fails.
     */
    findStatementsByTicker(
        ticker: string,
        statementType?: StatementTypes,
        limit?: number,
        sortOrder?: 1 | -1
    ): Promise<StatementDoc[]>;

 }


 class StatementDaoImpl implements StatementDao {
    private collection: Collection<StatementDoc>;
    private log: Log;

    private readonly COLLECTION_NAME = 'statements'; // Define collection name centrally

    // DAO constructor gets Db object and logger INSTANCE injected
    constructor(db: Db, loggingSvc: LoggingService) {
        this.collection = db.collection<StatementDoc>(this.COLLECTION_NAME);
        this.log = loggingSvc.getLogger('mongo-ops'); // Use the passed-in logger instance
        this.log.info(`StatementDao initialized for collection: ${this.COLLECTION_NAME}`);
        // Ensure indexes exist (call asynchronously, don't block constructor)
        this.ensureIndexes().catch(err => {
            this.log.error("Error ensuring indexes during initialization.", err);
        });
    }

    /**
     * Creates necessary indexes if they don't already exist.
     * Should be called once during application startup or DAO initialization.
     */
    private async ensureIndexes(): Promise<void> {
        this.log.debug("Ensuring indexes exist for 'statements' collection...");
        try {
            // Unique index to prevent duplicate statements for the same source file in a filing
            await this.collection.createIndex(
                { cik: 1, accessionNumber: 1, formType: 1, sourceFile: 1 },
                { unique: true, name: "filing_statement_source_unique_idx" }
            );
            // Index for finding statements by ticker and type, sorted by date
            await this.collection.createIndex(
                { ticker: 1, stmtType: 1, filingDate: -1 },
                { name: "ticker_stmtType_filingDate_idx" }
            );
            // Index for finding all statements for a specific filing
            await this.collection.createIndex(
                { cik: 1, accessionNumber: 1, formType: 1 },
                { name: "filing_lookup_idx" }
            );
            this.log.info("Successfully ensured indexes for 'statements' collection.");
        } catch (indexError: any) {
            // Log index creation errors but don't necessarily crash the app
            // MongoDB handles duplicate index creation gracefully (noop)
            if (indexError.codeName === 'IndexOptionsConflict' || indexError.codeName === 'IndexKeySpecsConflict') {
                this.log.warn(`Index conflict detected for 'statements' collection (likely already exists): ${indexError.message}`);
            } else {
                this.log.error("Error creating indexes for 'statements' collection.", indexError);
                // Depending on error, you might want to throw or handle differently
            }
        }
    }

    /**
     * Implements upsertStatement from IStatementDao.
     */
    async upsertStatement(statementDoc: StatementDoc): Promise<boolean> {
        // Define filter based on unique identifier fields
        const filter = {
            cik: statementDoc.cik,
            accessionNumber: statementDoc.accessionNumber,
            formType: statementDoc.formType,
            sourceFile: statementDoc.sourceFile // Include sourceFile for uniqueness
        };

        // Ensure processedAt is set
        const docToUpsert = {
            ...statementDoc,
            processedAt: new Date() // Update timestamp on every upsert
        };

        this.log.debug(`Upserting statement`, { filter });
        try {
            const result: UpdateResult = await this.collection.updateOne(
                filter,
                { $set: docToUpsert }, // Use $set to update all fields if found, or insert if not
                { upsert: true }       // Create document if it doesn't exist
            );
            this.log.info(`Upsert result for statement ${filter.sourceFile}: matched=${result.matchedCount}, modified=${result.modifiedCount}, upsertedId=${result.upsertedId}`);
            // Return true if a document was inserted OR an existing one was matched/modified
            return result.modifiedCount > 0 || result.matchedCount > 0 || !!result.upsertedId;
        } catch (error: any) {
            this.log.error(`Error upserting statement`);
            // Throw a specific DB error, wrapping the original
            throw new DatabaseError(`Database upsert failed for statement ${filter.sourceFile}`, error);
        }
    }

    /**
     * Implements findStatementsByFiling from IStatementDao.
     */
    async findStatementsByFiling(cik: string, accessionNumber: string, formType: string): Promise<StatementDoc[]> {
        const filter = { cik, accessionNumber, formType };
        this.log.debug(`Finding statements by filing`, { filter });
        try {
            const documents = await this.collection.find(filter).toArray();
            this.log.info(`Found ${documents.length} statements for filing`, { filter });
            return documents;
        } catch (error: any) {
            this.log.error(`Error finding statements by filing`);
            throw new DatabaseError(`Database find failed for filing ${accessionNumber}`, error);
        }
    }

    /**
     * Implements findStatementsByTicker from IStatementDao.
     */
    async findStatementsByTicker(
        ticker: string,
        statementType?: string,
        limit: number = 20, // Default limit
        sortOrder: 1 | -1 = -1 // Default sort descending (most recent first)
    ): Promise<StatementDoc[]> {
        const filter: Filter<StatementDoc> = { ticker };
        if (statementType) {
            filter.statementType = statementType;
        }
        const sort: Sort = { filingDate: sortOrder };

        this.log.debug(`Finding statements by ticker`, { filter, limit, sort });
        try {
            const documents = await this.collection.find(filter)
                .sort(sort)
                .limit(limit)
                .toArray();
            this.log.info(`Found ${documents.length} statements for ticker ${ticker}`, { filter, limit });
            return documents;
        } catch (error: any) {
            this.log.error(`Error finding statements by ticker ${ticker}`);
            throw new DatabaseError(`Database find failed for ticker ${ticker}`, error);
        }
    }
}
