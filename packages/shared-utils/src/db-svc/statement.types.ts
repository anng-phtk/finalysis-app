import { Collection, Db, Filter, ObjectId, Sort, UpdateResult } from "mongodb";
import { DatabaseError } from "../error-handlers/app-errors.js";
import { Log, LoggingService } from "../logging/logging.types.js";
import { StatementTypes } from "../app-config/ApplicationConfig.js";

/**
 * Represents one line item with a single value.
 * Example: { "Net Revenue": 12345 }
 **/
export type SingleValueItem = Record<string, string | number>;

/**
 * Represents one line item with multiple values (typically for Equity statements).
 * Example: { "Common Stock": [100, 110, 120] }
 **/
export type MultiValueItem = Record<string, string[] | number[]>;
export interface StatementDoc {
        /**
         * Unique identifier. Can be auto-generated by Mongo (ObjectId)
         * or a custom composite string like CIK_ACCESSION_FORMTYPE_STMTTYPE_SOURCEFILE.
         */
        _id?: string | ObjectId;
    
        // --- Context Fields (From FilingDataConfig) ---
        ticker: string;
        cik: string; // Store canonical CIK (string)
        accessionNumber: string; // Store canonical accession number
        formType: string; // e.g., '10-K', '10-Q'
        filingDate: Date; // Store as native BSON Date
        reportDate?: Date; // Store as native BSON Date (end date of the period reported)
        companyName?: string;
    
        // --- Statement Specific Fields ---
        /**
         * Type of statement (e.g., 'INCOME', 'BALANCE', 'CASHFLOW', 'EQUITY').
         * Used to determine the expected structure within parsedData.
         */
        statementType: string;
        /**
         * The source filename within the SEC filing (e.g., 'R1.htm', 'R5.htm').
         */
        sourceFile: string;
    
        /**
         * The actual parsed financial data. The structure of items within the array
         * depends on the statementType. Use type guards based on statementType
         * when reading this data.
         */
        parsedData: any; //Array<SingleValueItem | MultiValueItem>;
    
        // --- Metadata ---
        /**
         * Timestamp of when this document was created/updated in the database.
         */
        processedAt: Date;
    
}

export interface StatementDao {
    /**
     * Inserts a new statement document or updates an existing one
     * based on a unique combination of CIK, Accession Number, Form Type, and Source File.
     * @param statementDoc - The complete statement document to save.
     * @returns {Promise<boolean>} - True if a document was inserted or updated, false otherwise.
     * @throws {DatabaseError} - If the database operation fails.
     */
    upsertStatement(statement:StatementDoc):Promise<boolean>;

    /**
     * Finds all statement documents associated with a specific SEC filing.
     * @param ticker - The ticker of the company.
     * @param accessionNumber - The accession number of the filing.
     * @param formType - The form type (e.g., '10-K').
     * @returns {Promise<StatementDoc[]>} - An array of matching statement documents.
     * @throws {DatabaseError} - If the database operation fails.
     */
    findStatementsByFiling(ticker: string, accessionNumber: string, formType: string): Promise<StatementDoc[]>;

    /**
     * Finds statement documents for a specific ticker, optionally filtered by statement type.
     * @param ticker - The stock ticker symbol.
     * @param limit - Optional: Maximum number of results to return.
     * @param sortOrder - Optional: Sort direction for filingDate (-1 for descending, 1 for ascending).
     * @returns {Promise<StatementDoc[]>} - An array of matching statement documents.
     * @throws {DatabaseError} - If the database operation fails.
     */
    findStatementsByTicker(
        ticker: string,
        statementType?: StatementTypes,
        formType?:string,
        limit?: number,
        sortOrder?: 1 | -1
    ): Promise<StatementDoc[]>;

 }

